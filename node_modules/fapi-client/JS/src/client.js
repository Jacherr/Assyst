"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var types_1 = require("./types");
var detritus_rest_1 = require("detritus-rest");
var package_json_1 = __importDefault(require("../package.json"));
var os_1 = __importDefault(require("os"));
var Api = __importStar(require("./endpoints"));
var errors_1 = require("./errors");
var defaultSettings = {
    timeout: 15000
};
var userAgent = "fAPIClient v" + package_json_1.default.version + " (" + os_1.default.type() + " " + os_1.default.release() + "; " + os_1.default.arch() + ")";
/**
*  The main client. All fAPI endpoints can be accessed and requested from here.
*/
var Client = /** @class */ (function (_super) {
    __extends(Client, _super);
    function Client(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.ratelimitState = {};
        if (options.auth && !options.auth.startsWith('Bearer')) {
            _this.auth = "Bearer " + options.auth;
        }
        else if (options.auth && options.auth.startsWith('Bearer')) {
            _this.auth = options.auth;
        }
        else {
            _this.auth = '';
        }
        _this.baseUrl = options.baseUrl || Api.Base;
        var settings = defaultSettings;
        if (options.timeout)
            settings.timeout = options.timeout;
        _this.restClient = new detritus_rest_1.Client({
            headers: {
                Authorization: _this.auth,
                'user-agent': userAgent
            },
            settings: settings,
            baseUrl: _this.baseUrl
        });
        return _this;
    }
    Object.defineProperty(Client.prototype, "ratelimits", {
        /**
        * The most recently returned ratelimit headers, if any.
        */
        get: function () {
            return this.ratelimitState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Client.prototype, "timeout", {
        /**
        * The timeout for every request sent to fAPI.
        */
        get: function () {
            return this.restClient.settings.timeout;
        },
        set: function (value) {
            this.restClient.settings.timeout = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
    * The main request function. This function is mainly for internal use, since the client already implements this function for every endpoint.
    */
    Client.prototype.request = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var res, headers, ratelimitHeaders, ratelimitHeaders_1, ratelimitHeaders_1_1, headerKey, ratelimitReset, body, returnValue, _a, json, _b;
            var e_1, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (options.method !== types_1.HttpMethods.GET && options.headers) {
                            options.headers[types_1.ReturnHeaders.CONTENT_TYPE] = options.contentType || 'application/json';
                        }
                        this.emit('request', { request: options });
                        return [4 /*yield*/, this.restClient.request(options)];
                    case 1:
                        res = _d.sent();
                        headers = res.headers;
                        ratelimitHeaders = [types_1.ReturnHeaders.RATELIMIT_LIMIT, types_1.ReturnHeaders.RATELIMIT_REMAINING, types_1.ReturnHeaders.RATELIMIT_RESET];
                        try {
                            for (ratelimitHeaders_1 = __values(ratelimitHeaders), ratelimitHeaders_1_1 = ratelimitHeaders_1.next(); !ratelimitHeaders_1_1.done; ratelimitHeaders_1_1 = ratelimitHeaders_1.next()) {
                                headerKey = ratelimitHeaders_1_1.value;
                                if (headers[headerKey]) {
                                    // We can ignore ts warning here because `headerKey` will never be a key not referenced by RatelimitState
                                    // @ts-ignore
                                    this.ratelimitState[headerKey] = headers[headerKey];
                                }
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (ratelimitHeaders_1_1 && !ratelimitHeaders_1_1.done && (_c = ratelimitHeaders_1.return)) _c.call(ratelimitHeaders_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        ;
                        if (res.statusCode === 429) {
                            ratelimitReset = parseInt(res.headers[types_1.ReturnHeaders.RATELIMIT_RESET]);
                            if (isNaN(ratelimitReset)) {
                                ratelimitReset = 0;
                            }
                            this.emit('ratelimit', { request: options, response: res, ratelimitReset: ratelimitReset });
                            throw new errors_1.RatelimitError(ratelimitReset, res.request);
                        }
                        this.emit('response', { response: res });
                        if (!!(res.statusCode === 200)) return [3 /*break*/, 3];
                        return [4 /*yield*/, res.body()];
                    case 2:
                        body = _d.sent();
                        throw new errors_1.FapiError(body, res.statusCode, res.request);
                    case 3:
                        _a = options.returnType;
                        switch (_a) {
                            case types_1.ReturnMethods.BODY: return [3 /*break*/, 4];
                            case types_1.ReturnMethods.JSON: return [3 /*break*/, 6];
                        }
                        return [3 /*break*/, 12];
                    case 4: return [4 /*yield*/, res.body()];
                    case 5:
                        returnValue = _d.sent();
                        return [3 /*break*/, 13];
                    case 6:
                        json = void 0;
                        _d.label = 7;
                    case 7:
                        _d.trys.push([7, 9, , 11]);
                        return [4 /*yield*/, res.json()];
                    case 8:
                        json = _d.sent();
                        return [3 /*break*/, 11];
                    case 9:
                        _b = _d.sent();
                        return [4 /*yield*/, res.body()];
                    case 10:
                        returnValue = _d.sent();
                        return [3 /*break*/, 11];
                    case 11:
                        returnValue = json;
                        return [3 /*break*/, 13];
                    case 12:
                        returnValue = res;
                        _d.label = 13;
                    case 13:
                        if (options.returnHeaders) {
                            returnValue = { body: returnValue, headers: res.headers };
                        }
                        return [2 /*return*/, returnValue];
                }
            });
        });
    };
    /**
    * The standard internal request function for endpoints that return an image buffer. The request options for each endpoint here are similar, so we can use a function for it.
    */
    Client.prototype.fetchImage = function (endpoint, body) {
        if (!endpoint.startsWith('/'))
            endpoint = '/' + endpoint;
        return this.request({
            method: types_1.HttpMethods.POST,
            route: {
                path: endpoint
            },
            body: body,
            returnType: types_1.ReturnMethods.BODY
        });
    };
    /**
    * A specific internal request function that handles endpoints that only take an image URL as input and return an image buffer.
    */
    Client.prototype.requestImageFromImage = function (endpoint, image) {
        var body = {
            images: [image]
        };
        return this.fetchImage(endpoint, body);
    };
    /**
    * A specific internal request function that handles endpoints that only take text as input and return an image buffer.
    */
    Client.prototype.requestImageFromText = function (endpoint, text) {
        var body = {
            args: {
                text: text
            }
        };
        return this.fetchImage(endpoint, body);
    };
    /**
    * A specific internal request function that handles endpoints that only takes text and an image URL as inputs and returns an image buffer.
    */
    Client.prototype.requestImageFromBoth = function (endpoint, image, text) {
        var body = {
            images: [image],
            args: {
                text: text
            }
        };
        return this.fetchImage(endpoint, body);
    };
    Client.prototype.getPaths = function () {
        return this.request({
            method: types_1.HttpMethods.GET,
            route: {
                path: Api.Routes.PATHLIST
            },
            returnType: types_1.ReturnMethods.JSON
        });
    };
    Client.prototype.fetch4ChanBoard = function (options) {
        if (options === void 0) { options = {}; }
        var path = Api.Routes._4CHAN.toString();
        if (options.board) {
            path += "/" + options.board;
            if (options.thread) {
                path += "/" + options.thread;
            }
        }
        return this.request({
            method: types_1.HttpMethods.GET,
            route: {
                path: path
            },
            returnType: types_1.ReturnMethods.BODY
        });
    };
    Client.prototype._9Gag = function (image) {
        return this.requestImageFromImage(Api.Routes._9GAG, image);
    };
    Client.prototype.adidas = function (image) {
        return this.requestImageFromImage(Api.Routes.ADIDAS, image);
    };
    Client.prototype.adminWalk = function (image) {
        return this.requestImageFromImage(Api.Routes.ADW, image);
    };
    Client.prototype.aiMagik = function (image) {
        return this.requestImageFromImage(Api.Routes.AIMAGIK, image);
    };
    Client.prototype.ajit = function (image) {
        return this.requestImageFromImage(Api.Routes.AJIT, image);
    };
    Client.prototype.america = function (image) {
        return this.requestImageFromImage(Api.Routes.AMERICA, image);
    };
    Client.prototype.analysis = function (image) {
        return this.requestImageFromImage(Api.Routes.ANALYSIS, image);
    };
    Client.prototype.austin = function (image) {
        return this.requestImageFromImage(Api.Routes.AUSTIN, image);
    };
    Client.prototype.autism = function (image) {
        return this.requestImageFromImage(Api.Routes.AUTISM, image);
    };
    Client.prototype.bandicam = function (image) {
        return this.requestImageFromImage(Api.Routes.BANDICAM, image);
    };
    Client.prototype.bernie = function (image) {
        return this.requestImageFromImage(Api.Routes.BERNIE, image);
    };
    Client.prototype.binoculars = function (image) {
        return this.requestImageFromImage(Api.Routes.BINOCULARS, image);
    };
    Client.prototype.blackify = function (image) {
        return this.requestImageFromImage(Api.Routes.BLACKIFY, image);
    };
    Client.prototype.blackPanther = function (image) {
        return this.requestImageFromImage(Api.Routes.BLACKPANTHER, image);
    };
    Client.prototype.bobRoss = function (image) {
        return this.requestImageFromImage(Api.Routes.BOBROSS, image);
    };
    Client.prototype.buzzFeed = function (text) {
        // not using Client.requestImageFromText because text can be undefined here
        var body = {
            args: {
                text: text
            }
        };
        return this.fetchImage(Api.Routes.BUZZFEED, body);
    };
    Client.prototype.changeMyMind = function (text) {
        return this.requestImageFromText(Api.Routes.CHANGEMYMIND, text);
    };
    Client.prototype.composite = function (images) {
        var body = {
            images: Array.isArray(images) ? images : [images]
        };
        return this.fetchImage(Api.Routes.COMPOSITE, body);
    };
    Client.prototype.consent = function (image, text) {
        return this.requestImageFromBoth(Api.Routes.CONSENT, image, text);
    };
    Client.prototype.coolGuy = function (image) {
        return this.requestImageFromImage(Api.Routes.COOLGUY, image);
    };
    Client.prototype.days = function (text) {
        return this.requestImageFromText(Api.Routes.DAYS, text);
    };
    Client.prototype.deepfry = function (image, strength) {
        var body = {
            images: [image],
            args: {
                text: strength
            }
        };
        return this.fetchImage(Api.Routes.DEEPFRY, body);
    };
    Client.prototype.depression = function (image) {
        return this.requestImageFromImage(Api.Routes.DEPRESSION, image);
    };
    Client.prototype.disabled = function (image) {
        return this.requestImageFromImage(Api.Routes.DISABLED, image);
    };
    Client.prototype.dork = function (image) {
        return this.requestImageFromImage(Api.Routes.DORK, image);
    };
    Client.prototype.duckDuckGo = function (query) {
        var body = {
            args: {
                text: query
            }
        };
        return this.request({
            method: types_1.HttpMethods.POST,
            route: {
                path: Api.Routes.DUCKDUCKGO
            },
            body: body,
            returnType: types_1.ReturnMethods.JSON
        });
    };
    Client.prototype.duckDuckGoImages = function (query, options) {
        if (options === void 0) { options = {}; }
        var safetyLevel = -2;
        if (options.safe === undefined || options.safe === true)
            safetyLevel = 1;
        var body = {
            args: {
                text: query,
                safetyLevel: safetyLevel
            }
        };
        return this.request({
            method: types_1.HttpMethods.POST,
            route: {
                path: Api.Routes.DUCKDUCKGOIMAGES
            },
            body: body,
            returnType: types_1.ReturnMethods.JSON
        });
    };
    Client.prototype.edges = function (image) {
        return this.requestImageFromImage(Api.Routes.EDGES, image);
    };
    Client.prototype.edges2Emojis = function (image) {
        return this.requestImageFromImage(Api.Routes.EDGES2EMOJIS, image);
    };
    Client.prototype.edges2EmojisGif = function (image) {
        return this.requestImageFromImage(Api.Routes.EDGES2EMOJISGIF, image);
    };
    Client.prototype.edges2Porn = function (image) {
        return this.requestImageFromImage(Api.Routes.EDGES2PORN, image);
    };
    Client.prototype.edges2PornGif = function (image) {
        return this.requestImageFromImage(Api.Routes.EDGES2PORNGIF, image);
    };
    Client.prototype.emojify = function (image, text, foregroundEmoji, backgroundEmoji, options) {
        if (options === void 0) { options = {}; }
        var body = {
            images: [image],
            args: {
                text: text,
                foreground: foregroundEmoji,
                background: backgroundEmoji,
                vertical: options.vertical
            }
        };
        return this.request({
            method: types_1.HttpMethods.POST,
            route: {
                path: Api.Routes.EMOJIFY
            },
            body: body,
            returnType: types_1.ReturnMethods.BODY
        });
    };
    Client.prototype.emojiMosaic = function (image, options) {
        if (options === void 0) { options = {}; }
        var _a;
        return this.requestImageFromBoth(Api.Routes.EMOJIMOSAIC, image, ((_a = options.resolution) === null || _a === void 0 ? void 0 : _a.toString()) || '');
    };
    Client.prototype.eval = function (text, options) {
        if (options === void 0) { options = {}; }
        var body = {
            args: {
                text: text,
                target: options.target
            }
        };
        return this.request({
            method: types_1.HttpMethods.POST,
            route: {
                path: Api.Routes.EVAL
            },
            body: body,
            returnType: types_1.ReturnMethods.BODY
        });
    };
    Client.prototype.evalMagik = function (image, text) {
        var body = {
            images: [image],
            args: {
                text: text
            }
        };
        return this.fetchImage(Api.Routes.EVALMAGIK, body);
    };
    Client.prototype.excuse = function (image) {
        return this.requestImageFromImage(Api.Routes.EXCUSE, image);
    };
    Client.prototype.eyes = function (image, overlay) {
        return this.requestImageFromBoth(Api.Routes.EYES, image, overlay);
    };
    Client.prototype.faceDetection = function (image) {
        var body = {
            images: [image]
        };
        return this.request({
            method: types_1.HttpMethods.POST,
            route: {
                path: Api.Routes.FACEDETECTION
            },
            body: body,
            returnType: types_1.ReturnMethods.JSON
        });
    };
    Client.prototype.faceMagik = function (image, options) {
        if (options === void 0) { options = {}; }
        var body = {
            images: [image],
            args: {
                text: options.text,
                option: options.option
            }
        };
        return this.fetchImage(Api.Routes.FACEMAGIK, body);
    };
    Client.prototype.faceOverlay = function (sourceImage, overlayImage) {
        var body = {
            images: [sourceImage, overlayImage]
        };
        return this.fetchImage(Api.Routes.FACEOVERLAY, body);
    };
    Client.prototype.faceSwap = function (image) {
        return this.requestImageFromImage(Api.Routes.FACESWAP, image);
    };
    Client.prototype.gaben = function (image) {
        return this.requestImageFromImage(Api.Routes.GABEN, image);
    };
    Client.prototype.gay = function (image) {
        return this.requestImageFromImage(Api.Routes.GAY, image);
    };
    Client.prototype.glitch = function (image, options) {
        if (options === void 0) { options = {}; }
        var body = {
            images: [image],
            args: {
                iterations: options.iterations,
                amount: options.amount
            }
        };
        return this.fetchImage(Api.Routes.GLITCH, body);
    };
    Client.prototype.glow = function (image, options) {
        if (options === void 0) { options = {}; }
        var body = {
            images: [image],
            args: {
                text: options.amount
            }
        };
        return this.fetchImage(Api.Routes.GLOW, body);
    };
    Client.prototype.god = function (image) {
        return this.requestImageFromImage(Api.Routes.GOD, image);
    };
    Client.prototype.goldstar = function (image) {
        return this.requestImageFromImage(Api.Routes.GOLDSTAR, image);
    };
    Client.prototype.grill = function (text) {
        return this.requestImageFromText(Api.Routes.GRILL, text);
    };
    Client.prototype.hacker = function (text, template) {
        var body = {
            args: {
                text: text,
                template: template
            }
        };
        return this.fetchImage(Api.Routes.HACKER, body);
    };
    Client.prototype.hawking = function (image) {
        return this.requestImageFromImage(Api.Routes.HAWKING, image);
    };
    Client.prototype.hyperCam = function (image) {
        return this.requestImageFromImage(Api.Routes.HYPERCAM, image);
    };
    Client.prototype.iDubbbz = function (image) {
        return this.requestImageFromImage(Api.Routes.IDUBBBZ, image);
    };
    Client.prototype.iFunny = function (image) {
        return this.requestImageFromImage(Api.Routes.IFUNNY, image);
    };
    Client.prototype.imageScript = function (script, inject) {
        return __awaiter(this, void 0, void 0, function () {
            var body, res, contentType, imageType;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        body = {
                            args: {
                                text: script,
                                inject: inject
                            }
                        };
                        return [4 /*yield*/, this.request({
                                method: types_1.HttpMethods.POST,
                                body: body,
                                route: {
                                    path: Api.Routes.IMAGESCRIPT
                                },
                                returnHeaders: true,
                                returnType: types_1.ReturnMethods.BODY
                            })];
                    case 1:
                        res = _a.sent();
                        contentType = res.headers[types_1.ReturnHeaders.CONTENT_TYPE];
                        switch (contentType) {
                            case types_1.ContentTypes.PNG:
                                imageType = types_1.ImageTypes.PNG;
                                break;
                            case types_1.ContentTypes.GIF:
                                imageType = types_1.ImageTypes.GIF;
                                break;
                            default:
                                imageType = types_1.ImageTypes.PNG;
                        }
                        return [2 /*return*/, {
                                image: res.body,
                                format: imageType,
                                wallTime: parseFloat(res.headers[types_1.ReturnHeaders.IMAGESCRIPT_WALLTIME]),
                                cpuTime: parseFloat(res.headers[types_1.ReturnHeaders.IMAGESCRIPT_CPUTIME]),
                                memoryUsage: parseFloat(res.headers[types_1.ReturnHeaders.IMAGESCRIPT_MEMORY]) // mb
                            }];
                }
            });
        });
    };
    Client.prototype.imageTagParser = function (text) {
        return this.requestImageFromText(Api.Routes.IMAGETAGPARSER, text);
    };
    Client.prototype.index = function () {
        return this.request({
            method: types_1.HttpMethods.GET,
            url: this.baseUrl,
            returnType: types_1.ReturnMethods.BODY
        });
    };
    Client.prototype.israel = function (image) {
        return this.requestImageFromImage(Api.Routes.ISRAEL, image);
    };
    Client.prototype.jack = function (image) {
        return this.requestImageFromImage(Api.Routes.JACK, image);
    };
    Client.prototype.jackoff = function (image) {
        return this.requestImageFromImage(Api.Routes.JACKOFF, image);
    };
    Client.prototype.jesus = function (image) {
        return this.requestImageFromImage(Api.Routes.JESUS, image);
    };
    Client.prototype.keemstar = function (image) {
        return this.requestImageFromImage(Api.Routes.KEEMSTAR, image);
    };
    Client.prototype.keemstar2 = function (image) {
        return this.requestImageFromImage(Api.Routes.KEEMSTAR2, image);
    };
    Client.prototype.kekistan = function (image) {
        return this.requestImageFromImage(Api.Routes.KEKISTAN, image);
    };
    Client.prototype.kirby = function (image) {
        return this.requestImageFromImage(Api.Routes.KIRBY, image);
    };
    Client.prototype.lego = function (image, options) {
        if (options === void 0) { options = {}; }
        var body = {
            images: [image],
            args: {
                text: options.resolution
            }
        };
        return this.fetchImage(Api.Routes.LEGO, body);
    };
    Client.prototype.linus = function (image) {
        return this.requestImageFromImage(Api.Routes.LINUS, image);
    };
    Client.prototype.logan = function (image) {
        return this.requestImageFromImage(Api.Routes.LOGAN, image);
    };
    Client.prototype.logout = function (text) {
        return this.requestImageFromText(Api.Routes.LOGOUT, text);
    };
    Client.prototype.magikScript = function (image, text, options) {
        if (options === void 0) { options = {}; }
        var body = {
            images: [image],
            args: {
                text: text,
                options: options.options,
                size: options.size,
                gif: options.gif
            }
        };
        return this.fetchImage(Api.Routes.MAGIKSCRIPT, body);
    };
    Client.prototype.memorial = function (text) {
        return this.requestImageFromText(Api.Routes.MEMORIAL, text);
    };
    Client.prototype.miranda = function (image) {
        return this.requestImageFromImage(Api.Routes.MIRANDA, image);
    };
    Client.prototype.mistake = function (image) {
        return this.requestImageFromImage(Api.Routes.MISTAKE, image);
    };
    Client.prototype.nooseguy = function (image) {
        return this.requestImageFromImage(Api.Routes.NOOSEGUY, image);
    };
    Client.prototype.northKorea = function (image) {
        return this.requestImageFromImage(Api.Routes.NORTHKOREA, image);
    };
    Client.prototype.oldGuy = function (image) {
        return this.requestImageFromImage(Api.Routes.OLDGUY, image);
    };
    Client.prototype.owo = function (image) {
        return this.requestImageFromImage(Api.Routes.OWO, image);
    };
    Client.prototype.perfection = function (image) {
        return this.requestImageFromImage(Api.Routes.PERFECTION, image);
    };
    Client.prototype.ping = function () {
        return __awaiter(this, void 0, void 0, function () {
            var start;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        start = Date.now();
                        return [4 /*yield*/, this.index()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, Date.now() - start];
                }
            });
        });
    };
    Client.prototype.pistol = function (image) {
        return this.requestImageFromImage(Api.Routes.PISTOL, image);
    };
    Client.prototype.pixelate = function (image, options) {
        if (options === void 0) { options = {}; }
        var body = {
            images: [image],
            args: {
                amount: options.amount
            }
        };
        return this.fetchImage(Api.Routes.PIXELATE, body);
    };
    Client.prototype.pne = function (image, options) {
        if (options === void 0) { options = {}; }
        var body = {
            images: [image],
            args: {
                option: options.option
            }
        };
        return this.fetchImage(Api.Routes.PNE, body);
    };
    Client.prototype.pornhub = function (image, text) {
        return this.requestImageFromBoth(Api.Routes.PORNHUB, image, text);
    };
    Client.prototype.portal = function (image) {
        return this.requestImageFromImage(Api.Routes.PORTAL, image);
    };
    Client.prototype.presidential = function (text) {
        return this.requestImageFromText(Api.Routes.PRESIDENTIAL, text);
    };
    Client.prototype.proxy = function (url, reqBody) {
        var body = {
            body: reqBody
        };
        var query = {
            url: url
        };
        return this.request({
            method: types_1.HttpMethods.POST,
            route: {
                path: Api.Routes.PROXY
            },
            query: query,
            body: body,
            returnType: types_1.ReturnMethods.BODY
        });
    };
    Client.prototype.quote = function (options) {
        var body = {
            args: options
        };
        return this.fetchImage(Api.Routes.QUOTE, body);
    };
    Client.prototype.racecard = function (light, dark) {
        var body = {
            args: {
                text: [light, dark]
            }
        };
        return this.fetchImage(Api.Routes.RACECARD, body);
    };
    Client.prototype.realFact = function (text) {
        return this.requestImageFromText(Api.Routes.REALFACT, text);
    };
    Client.prototype.recaptcha = function (text) {
        return this.requestImageFromText(Api.Routes.RECAPTCHA, text);
    };
    Client.prototype.reminder = function (image, text) {
        return this.requestImageFromBoth(Api.Routes.REMINDER, image, text);
    };
    Client.prototype.resize = function (image) {
        return this.requestImageFromImage(Api.Routes.RESIZE, image);
    };
    Client.prototype.respects = function (image) {
        return this.requestImageFromImage(Api.Routes.RESPECTS, image);
    };
    Client.prototype.retro = function (image, text) {
        return this.requestImageFromBoth(Api.Routes.RETRO, image, text);
    };
    Client.prototype.rexTester = function (language, code) {
        var body = {
            args: {
                language: language,
                text: code
            }
        };
        return this.request({
            method: types_1.HttpMethods.POST,
            route: {
                path: Api.Routes.REXTESTER
            },
            body: body,
            returnType: types_1.ReturnMethods.JSON
        });
    };
    Client.prototype.rtx = function (before, after) {
        var body = {
            images: [before, after]
        };
        return this.fetchImage(Api.Routes.RTX, body);
    };
    Client.prototype.russia = function (image) {
        return this.requestImageFromImage(Api.Routes.RUSSIA, image);
    };
    Client.prototype.screenshot = function (url, options) {
        if (options === void 0) { options = {}; }
        var body = {
            args: {
                text: url,
                wait: options.wait,
                allowNSFW: options.allowNSFW
            }
        };
        return this.fetchImage(Api.Routes.SCREENSHOT, body);
    };
    Client.prototype.shit = function (image) {
        return this.requestImageFromImage(Api.Routes.SHIT, image);
    };
    Client.prototype.shooting = function (image, text) {
        return this.requestImageFromBoth(Api.Routes.SHOOTING, image, text);
    };
    Client.prototype.shotgun = function (image) {
        return this.requestImageFromImage(Api.Routes.SHOTGUN, image);
    };
    Client.prototype.simpsonsDisabled = function (text) {
        return this.requestImageFromText(Api.Routes.SIMPSONSDISABLED, text);
    };
    Client.prototype.smg = function (image) {
        return this.requestImageFromImage(Api.Routes.SMG, image);
    };
    Client.prototype.snapchat = function (image, options) {
        if (options === void 0) { options = {}; }
        var body = {
            images: [image],
            args: {
                text: options.filter,
                snow: options.snow
            }
        };
        return this.fetchImage(Api.Routes.SNAPCHAT, body);
    };
    Client.prototype.sonic = function (text) {
        return this.requestImageFromText(Api.Routes.SONIC, text);
    };
    Client.prototype.spain = function (image) {
        return this.requestImageFromImage(Api.Routes.SPAIN, image);
    };
    Client.prototype.starman = function (image) {
        return this.requestImageFromImage(Api.Routes.STARMAN, image);
    };
    Client.prototype.steamPlaying = function (game) {
        var body = {
            args: {
                text: game
            }
        };
        var query = {
            json: true
        };
        return this.request({
            method: types_1.HttpMethods.POST,
            route: {
                path: Api.Routes.STEAMPLAYING
            },
            query: query,
            body: body,
            returnType: types_1.ReturnMethods.JSON
        });
    };
    Client.prototype.stock = function (image) {
        return this.requestImageFromImage(Api.Routes.STOCK, image);
    };
    Client.prototype.supreme = function (image) {
        return this.requestImageFromImage(Api.Routes.SUPREME, image);
    };
    Client.prototype.thinking = function (image, options) {
        if (options === void 0) { options = {}; }
        var body = {
            images: [image],
            args: {
                level: options.level
            }
        };
        return this.fetchImage(Api.Routes.THINKING, body);
    };
    Client.prototype.thonkify = function (text) {
        return this.requestImageFromText(Api.Routes.THONKIFY, text);
    };
    Client.prototype.trans = function (image) {
        return this.requestImageFromImage(Api.Routes.TRANS, image);
    };
    Client.prototype.trump = function (image) {
        return this.requestImageFromImage(Api.Routes.TRUMP, image);
    };
    Client.prototype.ugly = function (image) {
        return this.requestImageFromImage(Api.Routes.UGLY, image);
    };
    Client.prototype.uk = function (image) {
        return this.requestImageFromImage(Api.Routes.UK, image);
    };
    Client.prototype.unmagik = function (image) {
        return this.requestImageFromImage(Api.Routes.UNMAGIK, image);
    };
    Client.prototype.urbanDictionary = function (query) {
        var body = {
            args: {
                text: query
            }
        };
        return this.request({
            method: types_1.HttpMethods.POST,
            route: {
                path: Api.Routes.URBANDICTIONARY
            },
            body: body,
            returnType: types_1.ReturnMethods.JSON
        });
    };
    Client.prototype.urlify = function (url) {
        var body = {
            args: {
                text: url
            }
        };
        return this.request({
            method: types_1.HttpMethods.POST,
            route: {
                path: Api.Routes.URLIFY
            },
            body: body,
            returnType: types_1.ReturnMethods.BODY
        });
    };
    Client.prototype.ussr = function (image) {
        return this.requestImageFromImage(Api.Routes.USSR, image);
    };
    Client.prototype.vending = function (image) {
        return this.requestImageFromImage(Api.Routes.VENDING, image);
    };
    Client.prototype.watchMojo = function (image, text) {
        return this.requestImageFromBoth(Api.Routes.WATCHMOJO, image, text);
    };
    Client.prototype.wheeze = function (image) {
        return this.requestImageFromImage(Api.Routes.WHEEZE, image);
    };
    Client.prototype.wikiHow = function (query) {
        var body = {
            args: {
                text: query
            }
        };
        return this.request({
            method: types_1.HttpMethods.POST,
            route: {
                path: Api.Routes.WIKIHOW
            },
            body: body,
            returnType: types_1.ReturnMethods.JSON
        });
    };
    Client.prototype.wonka = function (text) {
        return this.requestImageFromText(Api.Routes.WONKA, text);
    };
    Client.prototype.wth = function (image) {
        return this.requestImageFromImage(Api.Routes.WTH, image);
    };
    Client.prototype.yusuke = function (image) {
        return this.requestImageFromImage(Api.Routes.YUSUKE, image);
    };
    Client.prototype.zoom = function (image) {
        return this.requestImageFromImage(Api.Routes.ZOOM, image);
    };
    Client.prototype.zuckerberg = function (image) {
        return this.requestImageFromImage(Api.Routes.ZUCKERBERG, image);
    };
    Client.prototype.on = function (event, listener) {
        _super.prototype.on.call(this, event, listener);
        return this;
    };
    return Client;
}(events_1.EventEmitter));
exports.Client = Client;
