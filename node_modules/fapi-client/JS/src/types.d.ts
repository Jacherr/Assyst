/// <reference types="node" />
import { BeforeRequestOptions } from 'detritus-rest';
/**
* All HTTP request methods the client may use.
*/
export declare enum HttpMethods {
    GET = "GET",
    POST = "POST"
}
/**
* Each endpoint either returns JSON or string/buffer. The request function takes one of these as an option.
*/
export declare enum ReturnMethods {
    JSON = "json",
    BODY = "body"
}
/**
 * All specific headers that may be handled within the client itself.
 */
export declare enum ReturnHeaders {
    IMAGESCRIPT_CPUTIME = "x-imagescript-cputime",
    IMAGESCRIPT_WALLTIME = "x-imagescript-walltime",
    IMAGESCRIPT_MEMORY = "x-imagescript-memory",
    RATELIMIT_RESET = "x-rate-limit-reset",
    RATELIMIT_LIMIT = "x-rate-limit-limit",
    RATELIMIT_REMAINING = "x-rate-limit-remaining",
    CONTENT_TYPE = "content-type"
}
export declare enum ContentTypes {
    PNG = "image/png",
    GIF = "image/gif"
}
export declare enum ImageTypes {
    PNG = "png",
    GIF = "gif"
}
/**
 * The most recently returned ratelimit headers, if any.
 */
export interface RatelimitState {
    [ReturnHeaders.RATELIMIT_RESET]?: number;
    [ReturnHeaders.RATELIMIT_REMAINING]?: number;
    [ReturnHeaders.RATELIMIT_LIMIT]?: number;
}
/**
 * Events that the client may fire.
 */
export declare namespace RequestEvents {
    interface Request {
        request: Request;
    }
    interface Response {
        request: Request;
        response: Response;
    }
    interface Ratelimit {
        request: Request;
        response: Response;
        ratelimitReset: number;
    }
    type Events = 'ratelimit' | 'request' | 'response';
    type EventsPayload = Request | Response | Ratelimit;
}
/**
 * All request types documented here are 100% optional. All mandatory types are separate parameters.
 */
export declare namespace RequestTypes {
    type Request = (BeforeRequestOptions & {
        returnType?: ReturnMethods;
        contentType?: string;
        returnHeaders?: boolean;
    });
    interface _4Chan {
        board?: string;
        thread?: string;
    }
    interface DuckDuckGoImages {
        safe?: boolean;
    }
    interface Emojify {
        vertical?: boolean;
    }
    interface Eval {
        target?: 'local' | 'master' | 'workers';
    }
    type EyesOverlay = 'big' | 'black' | 'blood' | 'blue' | 'googly' | 'green' | 'horror' | 'illuminati' | 'money' | 'normal' | 'pink' | 'red' | 'small' | 'spinner' | 'spongebob' | 'white' | 'yellow' | 'lucille';
    interface FaceMagik {
        text?: 'rain' | 'gold' | 'swirl' | 'frost' | 'blur' | 'charcoal' | 'tehi' | 'pixelate' | 'spin' | 'magika' | 'implode' | 'explode' | 'circle' | 'pseudocolor' | 'kaleidoscope' | 'toon' | 'ripples' | 'e2p' | 'emoji' | 'magik';
        option?: 1 | 2 | 3;
    }
    interface Glitch {
        iterations?: number;
        amount?: number;
    }
    interface Glow {
        amount?: number;
    }
    type ImageScriptInject = {
        [key: string]: string | number;
    };
    interface Lego {
        resolution?: number;
    }
    interface MagikScript {
        options?: string[];
        size?: string;
        gif?: boolean;
    }
    interface Pixelate {
        amount?: number;
    }
    interface Pne {
        option?: 0 | 1 | 2 | 3 | 4;
    }
    namespace Quote {
        namespace Embed {
            interface Footer {
                text: string;
                icon_url?: string;
                proxy_icon_url?: string;
            }
            interface Image {
                url?: string;
                proxy_url?: string;
                height?: number;
                width?: number;
            }
            interface Thumbnail {
                url?: string;
                proxy_url?: string;
                height?: number;
                width?: number;
            }
            interface Video {
                url?: string;
                height?: number;
                width?: number;
            }
            interface Provider {
                name?: string;
                url?: string;
            }
            interface Author {
                name?: string;
                url?: string;
                icon_url?: string;
                proxy_icon_url?: string;
            }
            interface Field {
                name: string;
                value: string;
                inline?: boolean;
            }
            interface Embed {
                title?: string;
                type?: string;
                description?: string;
                url?: string;
                timestamp?: string;
                color?: number;
                footer?: Footer;
                image?: Image;
                thumbnail?: Thumbnail;
                video?: Video;
                provider?: Provider;
                author?: Author;
                fields?: Field[];
            }
        }
        interface Author {
            color: string;
            username: string;
            bot?: boolean;
            avatarURL: string;
        }
        interface Quote {
            message: Embed.Embed | string;
            author: Author;
            light?: boolean;
            compact?: boolean;
            timestamp: string;
        }
    }
    interface EmojiMosaic {
        resolution?: number;
    }
    interface Screenshot {
        allowNSFW?: boolean;
        wait?: number;
    }
    interface Snapchat {
        filter?: 'angery' | 'bambi' | 'dog ' | 'dog2' | 'bunny' | 'cat' | 'cat2' | 'christmas' | 'heart' | 'joy' | 'flowers' | 'flowers2' | 'devil' | 'glasses' | 'moustache' | 'notsobot' | 'autism' | 'sunglasses' | 'squidward' | 'thug' | 'thinking' | 'thanos';
        snow?: boolean;
    }
    interface Thinking {
        level?: string;
    }
}
/**
 * Everything that fAPI may return that is not a generic buffer or string.
 */
export declare namespace ReturnTypes {
    interface DuckDuckGo {
        results: DuckDuckGoResult[];
    }
    interface DuckDuckGoResult {
        title: string;
        link: string;
    }
    namespace FaceDetection {
        interface Result {
            faceRectangle: FaceRectangle;
            faceAttributes: FaceAttributes;
            faceLandmarks: FaceLandmarks;
            original: Original;
        }
        interface FaceAttributes {
            headPose: HeadPose;
        }
        interface HeadPose {
            roll: number;
            yaw: number;
            pitch: number;
        }
        interface FaceLandmarks {
            pupilLeft: PupilLeft;
            pupilRight: PupilLeft;
            mouth: Mouth;
        }
        interface Mouth {
            width: number;
            height: number;
            x: number;
            y: number;
        }
        interface PupilLeft {
            x: number;
            y: number;
        }
        interface FaceRectangle {
            top: number;
            left: number;
            width: number;
            height: number;
        }
        interface Original {
            face_token: string;
            face_rectangle: FaceRectangle;
            landmark: {
                [key: string]: PupilLeft;
            };
            attributes: Attributes;
        }
        interface Attributes {
            headpose: Headpose;
        }
        interface Headpose {
            pitch_angle: number;
            roll_angle: number;
            yaw_angle: number;
        }
    }
    interface ImageScript {
        image: Buffer;
        format: ImageTypes;
        cpuTime: number;
        wallTime: number;
        memoryUsage: number;
    }
    type PathList = {
        [key: string]: {
            methods: string[];
            routes: string[];
        };
    };
    interface UrbanDictionaryResult {
        header: string;
        meaning: string;
        example: string;
        tags: string[];
    }
    type UrbanDictionary = UrbanDictionaryResult[];
}
