"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
const encoder_1 = require("./encoder");
const errors_1 = require("./errors");
const EmptyBodyCodes = [
    constants_1.HTTPStatusCodes.NO_CONTENT,
    constants_1.HTTPStatusCodes.NOT_MODIFIED,
];
class Response {
    constructor(request, response, info, took, headers) {
        this.ended = false;
        this.request = request;
        this.took = took;
        switch (info.alpn) {
            case constants_1.ALPNProtocols.NONE:
            case constants_1.ALPNProtocols.HTTP1:
            case constants_1.ALPNProtocols.HTTP1_1:
                {
                    this.headers = response.headers;
                    this.statusCode = response.statusCode;
                }
                ;
                break;
            case constants_1.ALPNProtocols.HTTP2:
                {
                    this.headers = headers || {};
                    this.statusCode = parseInt(this.headers[constants_1.HTTPHeaders.HTTP2_STATUS]);
                }
                ;
                break;
            default:
                {
                    throw new errors_1.ResponseError(`Invalid ALPN Protocol: ${info.alpn}`, this);
                }
                ;
        }
        this.alpn = info.alpn;
        this.connection = info.connection;
        this.data = undefined;
        this.stream = response;
        Object.defineProperties(this, {
            connection: { enumerable: false, writable: false },
            data: { enumerable: false },
            stream: { enumerable: false, writable: false },
        });
        this.contentType = (this.headers[constants_1.HTTPHeaders.CONTENT_TYPE] || '').split(';').shift() || '';
    }
    get closed() {
        switch (this.alpn) {
            case constants_1.ALPNProtocols.NONE:
            case constants_1.ALPNProtocols.HTTP1:
            case constants_1.ALPNProtocols.HTTP1_1:
                {
                    return this.ended;
                }
                ;
            case constants_1.ALPNProtocols.HTTP2:
                {
                    return this.stream.closed;
                }
                ;
        }
        return true;
    }
    get ok() {
        return constants_1.HTTPStatusCodes.OK <= this.statusCode && this.statusCode < constants_1.HTTPStatusCodes.MULTIPLE_CHOICES;
    }
    close() {
        // if you dont get/want data, use this if http2 is used
        switch (this.alpn) {
            case constants_1.ALPNProtocols.HTTP2:
                {
                    if (!this.stream.closed) {
                        this.stream.close();
                    }
                    if (!this.connection.closed) {
                        this.connection.close();
                    }
                }
                ;
                break;
        }
        this.ended = true;
    }
    buffer() {
        return new Promise((resolve, reject) => {
            if (this.closed) {
                if (this.data === undefined) {
                    return reject(new errors_1.ResponseError(`Cannot get the body of a closed response.`, this));
                }
                return resolve(this.data);
            }
            this.stream.once('aborted', () => {
                reject(new errors_1.ResponseError(`Response was aborted by the server.`, this));
            });
            let stream = this.stream;
            if (constants_1.HTTPHeaders.CONTENT_ENCODING in this.headers &&
                this.headers[constants_1.HTTPHeaders.CONTENT_LENGTH] !== '0' &&
                !EmptyBodyCodes.includes(this.statusCode)) {
                stream = encoder_1.decodeMultiple(stream, this.headers[constants_1.HTTPHeaders.CONTENT_ENCODING].split(','));
            }
            const body = [];
            stream.on('data', (data) => {
                body.push(data);
            }).once('end', () => {
                this.close();
                switch (this.alpn) {
                    case constants_1.ALPNProtocols.NONE:
                    case constants_1.ALPNProtocols.HTTP1:
                    case constants_1.ALPNProtocols.HTTP1_1:
                        {
                            if (!this.stream.complete) {
                                return reject(new errors_1.ResponseError(`Response connection was terminated while receiving message.`, this));
                            }
                        }
                        ;
                        break;
                }
                if (body.length) {
                    if (body.length === 1) {
                        this.data = body.shift();
                    }
                    else {
                        this.data = Buffer.concat(body);
                    }
                }
                else {
                    this.data = null;
                }
                resolve(this.data);
            });
        });
    }
    async body() {
        const buffer = await this.buffer();
        if (buffer instanceof Buffer) {
            switch (this.contentType) {
                case constants_1.SupportedContentTypes.APPLICATION_JSON:
                    {
                        return JSON.parse(String(buffer));
                    }
                    ;
                case constants_1.SupportedContentTypes.TEXT_PLAIN:
                    {
                        return String(buffer);
                    }
                    ;
                default:
                    {
                        if (this.contentType.startsWith('text/')) {
                            return String(buffer);
                        }
                    }
                    ;
            }
        }
        return buffer;
    }
    async json() {
        const buffer = await this.buffer();
        if (buffer instanceof Buffer) {
            return JSON.parse(String(buffer));
        }
    }
    async text() {
        const buffer = await this.buffer();
        if (buffer instanceof Buffer) {
            return String(buffer);
        }
        return '';
    }
    toString() {
        return this.request.toString();
    }
}
exports.Response = Response;
