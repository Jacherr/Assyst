"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const constants_1 = require("./constants");
const request_1 = require("./request");
const route_1 = require("./route");
const defaultClientOptions = Object.freeze({
    settings: {
        timeout: 20000,
    },
    headers: {
        [constants_1.HTTPHeaders.USER_AGENT]: `detritus-rest (${constants_1.Package.URL}, ${constants_1.Package.VERSION})`,
    },
});
class Client {
    constructor(options) {
        options = Object.assign({}, defaultClientOptions, options);
        this.baseUrl = '';
        if (options.baseUrl) {
            if (options.baseUrl instanceof url_1.URL) {
                this.baseUrl = options.baseUrl;
            }
            else {
                this.baseUrl = new url_1.URL(options.baseUrl);
            }
        }
        this.headers = Object.assign({}, defaultClientOptions.headers);
        if (options.headers) {
            for (let key in options.headers) {
                if (options.headers[key] !== undefined) {
                    this.headers[key.toLowerCase()] = options.headers[key];
                }
            }
        }
        this.settings = Object.assign({}, defaultClientOptions.settings, options.settings);
    }
    async createRequest(options) {
        if (typeof (options) === 'string') {
            options = { url: options };
        }
        else {
            options = Object.assign({}, options);
        }
        let method = options.method;
        if (!method) {
            // set the method before it creates the route incase route doesn't contain one
            method = constants_1.HTTPMethods.GET;
        }
        if (options.route || options.path) {
            if (!options.route) {
                options.route = {};
            }
            if (!(options.route instanceof route_1.Route)) {
                options.route = new route_1.Route(options.route.method || method, options.route.path || options.path, options.route.params);
            }
            method = options.route.method;
        }
        method = method.toUpperCase(); // http2 requires uppercase
        if (!options.url && !options.route) {
            throw new Error('URL or Path has to be specified in a request!');
        }
        let url;
        if (options.route) {
            if (!this.baseUrl && !options.url) {
                throw new Error('Route or Path cannot be used without a url specified!');
            }
            url = new url_1.URL('', options.url || this.baseUrl);
            if (url.pathname.endsWith('/') && options.route.urlPath.startsWith('/')) {
                url.pathname += options.route.urlPath.slice(1);
            }
            else {
                url.pathname += options.route.urlPath;
            }
        }
        else {
            url = new url_1.URL('', options.url);
        }
        if (options.query) {
            for (let key in options.query) {
                appendQuery(url, key, options.query[key]);
            }
        }
        let body = options.body;
        if (body && constants_1.BodylessMethods.includes(method)) {
            // treat body as query
            if (typeof (body) === 'object') {
                for (let key in body) {
                    appendQuery(url, key, body[key]);
                }
            }
            body = null;
        }
        const headers = Object.assign({}, this.headers);
        if (options.headers) {
            for (let key in options.headers) {
                if (options.headers[key] !== undefined) {
                    headers[key.toLowerCase()] = options.headers[key];
                }
            }
        }
        return new request_1.Request({
            body,
            files: options.files,
            headers,
            jsonify: options.jsonify,
            method,
            multipart: options.multipart,
            route: options.route,
            settings: Object.assign({}, this.settings, options.settings),
            url,
        });
    }
    async request(options) {
        if (typeof (options) === 'string') {
            options = { url: options };
        }
        const request = await this.createRequest(options);
        return await request.send();
    }
    async delete(options) {
        if (typeof (options) === 'string') {
            options = { method: constants_1.HTTPMethods.DELETE, url: options };
        }
        else {
            options = Object.assign({}, options, { method: constants_1.HTTPMethods.DELETE });
        }
        return this.request(options);
    }
    async get(options) {
        if (typeof (options) === 'string') {
            options = { method: constants_1.HTTPMethods.GET, url: options };
        }
        else {
            options = Object.assign({}, options, { method: constants_1.HTTPMethods.GET });
        }
        return this.request(options);
    }
    async head(options) {
        if (typeof (options) === 'string') {
            options = { method: constants_1.HTTPMethods.HEAD, url: options };
        }
        else {
            options = Object.assign({}, options, { method: constants_1.HTTPMethods.HEAD });
        }
        return this.request(options);
    }
    async options(options) {
        if (typeof (options) === 'string') {
            options = { method: constants_1.HTTPMethods.OPTIONS, url: options };
        }
        else {
            options = Object.assign({}, options, { method: constants_1.HTTPMethods.OPTIONS });
        }
        return this.request(options);
    }
    async patch(options) {
        if (typeof (options) === 'string') {
            options = { method: constants_1.HTTPMethods.PATCH, url: options };
        }
        else {
            options = Object.assign({}, options, { method: constants_1.HTTPMethods.PATCH });
        }
        return this.request(options);
    }
    async post(options) {
        if (typeof (options) === 'string') {
            options = { method: constants_1.HTTPMethods.POST, url: options };
        }
        else {
            options = Object.assign({}, options, { method: constants_1.HTTPMethods.POST });
        }
        return this.request(options);
    }
    async put(options) {
        if (typeof (options) === 'string') {
            options = { method: constants_1.HTTPMethods.PUT, url: options };
        }
        else {
            options = Object.assign({}, options, { method: constants_1.HTTPMethods.PUT });
        }
        return this.request(options);
    }
}
exports.Client = Client;
function appendQuery(url, key, value) {
    if (value === undefined) {
        return;
    }
    if (Array.isArray(value)) {
        for (let v of value) {
            appendQuery(url, key, v);
        }
    }
    else {
        if (typeof (value) !== 'string') {
            value = String(value);
        }
        url.searchParams.append(key, value);
    }
}
exports.appendQuery = appendQuery;
