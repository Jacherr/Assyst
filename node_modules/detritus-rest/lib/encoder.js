"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Zlib = require("zlib");
var Encodings;
(function (Encodings) {
    Encodings["BR"] = "br";
    Encodings["DEFLATE"] = "deflate";
    Encodings["GZIP"] = "gzip";
})(Encodings || (Encodings = {}));
const AcceptedEncodings = [Encodings.GZIP, Encodings.DEFLATE];
exports.AcceptedEncodings = AcceptedEncodings;
const Encoders = {
    Brotli: null,
    Zlib,
};
exports.Encoders = Encoders;
if (Zlib.createBrotliCompress) {
    AcceptedEncodings.push(Encodings.BR);
}
else {
    try {
        Encoders.Brotli = require('iltorb');
        AcceptedEncodings.push(Encodings.BR);
    }
    catch (e) { }
}
function decode(stream, format) {
    format = format.trim();
    if (!AcceptedEncodings.includes(format)) {
        throw new Error(`Received unsupported encoding: ${format}.`);
    }
    switch (format) {
        case Encodings.BR:
            {
                if (Zlib.createBrotliCompress) {
                    stream = stream.pipe(Encoders.Zlib.createBrotliDecompress());
                }
                else {
                    stream = stream.pipe(Encoders.Brotli.decompressStream());
                }
            }
            ;
            break;
        case Encodings.DEFLATE:
            stream = stream.pipe(Encoders.Zlib.createInflate());
            break;
        case Encodings.GZIP:
            stream = stream.pipe(Encoders.Zlib.createGunzip());
            break;
    }
    return stream;
}
exports.decode = decode;
;
function decodeMultiple(stream, formats) {
    if (typeof (formats) === 'string') {
        stream = decode(stream, formats);
    }
    else {
        for (let format of formats) {
            stream = decode(stream, format);
        }
    }
    return stream;
}
exports.decodeMultiple = decodeMultiple;
;
